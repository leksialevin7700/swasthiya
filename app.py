from flask import Flask, render_template, request, redirect, url_for, session, send_file, jsonify,flash
import torch
import torch.nn as nn
from torchvision import transforms, models
from PIL import Image
from geopy.geocoders import Nominatim
import pandas as pd
import requests
import os
import google.generativeai as genai
from fpdf import FPDF
import io
import hashlib
from datetime import datetime, date
from pymongo import MongoClient
from bson.objectid import ObjectId
from langdetect import detect, LangDetectException

app = Flask(__name__)
app.secret_key = '4c6a2b6f1a234e6a2f4f25bfbf8a1f1e'

# MongoDB Setup
client = MongoClient("mongodb://localhost:27017/")
db = client['health_assistant']
users_collection = db['users']
chat_history_collection = db['chat_history']

# Translation dictionaries
translations = {
    'en': {
        'welcome': "Welcome! Please enter your city location:",
        'whats_bothering': "What's bothering you today?",
        'upload_image': "Please upload an image of the affected area.",
        'skin_response': "Image received. Now, let's ask some follow-up questions.",
        'general_response': "Thank you. Let's begin by asking some questions about your condition.",
        'analysis_title': "Medical Analysis (Generated By AI)",
        'patient_info': "Patient Information",
        'medical_analysis': "Medical Analysis",
        'hospitals': "Recommended Hospitals",
        'age': "Age",
        'gender': "Gender",
        'location': "Location",
        'address': "Address",
        'new_chat': "➕ New Chat",
        'prev_consults': "Previous Consultations",
        'return': "← Return to Current Chat"
    },
    'ta': {
        'welcome': "வணக்கம்! உங்கள் நகரத்தின் இடத்தை உள்ளிடவும்:",
        'whats_bothering': "இன்று உங்களை என்ன பாதிக்கிறது?",
        'upload_image': "பாதிக்கப்பட்ட பகுதியின் படத்தை பதிவேற்றம் செய்யவும்.",
        'skin_response': "படம் பெறப்பட்டது. இப்போது, சில பின்தொடர் கேள்விகளைக் கேட்போம்.",
        'general_response': "நன்றி. உங்கள் நிலை பற்றி சில கேள்விகளைக் கேட்போம்.",
        'analysis_title': "மருத்துவ பகுப்பாய்வு (AI மூலம் உருவாக்கப்பட்டது)",
        'patient_info': "நோயாளி தகவல்",
        'medical_analysis': "மருத்துவ பகுப்பாய்வு",
        'hospitals': "பரிந்துரைக்கப்பட்ட மருத்துவமனைகள்",
        'age': "வயது",
        'gender': "பாலினம்",
        'location': "இடம்",
        'address': "முகவரி",
        'new_chat': "➕ புதிய உரையாடல்",
        'prev_consults': "முந்தைய ஆலோசனைகள்",
        'return': "← தற்போதைய உரையாடலுக்கு திரும்பு"
    },
    'hi': {
        'welcome': "आपका स्वागत है! कृपया अपने शहर का स्थान दर्ज करें:",
        'whats_bothering': "आज आपको क्या परेशान कर रहा है?",
        'upload_image': "कृपया प्रभावित क्षेत्र की छवि अपलोड करें।",
        'skin_response': "छवि प्राप्त हुई। अब कुछ अनुवर्ती प्रश्न पूछते हैं।",
        'general_response': "धन्यवाद। आइए आपकी स्थिति के बारे में कुछ प्रश्न पूछकर शुरू करते हैं।",
        'analysis_title': "चिकित्सा विश्लेषण (एआई द्वारा उत्पन्न)",
        'patient_info': "रोगी की जानकारी",
        'medical_analysis': "चिकित्सा विश्लेषण",
        'hospitals': "सुझाए गए अस्पताल",
        'age': "उम्र",
        'gender': "लिंग",
        'location': "स्थान",
        'address': "पता",
        'new_chat': "➕ नई चैट",
        'prev_consults': "पिछली परामर्श",
        'return': "← वर्तमान चैट पर लौटें"
    }
}

skin_keywords = {
    'en': ['skin', 'rash', 'acne', 'eczema', 'dermatitis', 'lesion', 'melanoma'],
    'ta': ['தோல்', 'சிரங்கு', 'பரு', 'எக்சிமா', 'டெர்மடைடிஸ்', 'கட்டி', 'மெலனோமா'],
    'hi': ['त्वचा', 'दाने', 'मुंहासे', 'एक्जिमा', 'डर्मेटाइटिस', 'घाव', 'मेलेनोमा']
}

language_names = {
    'en': 'English',
    'ta': 'Tamil',
    'hi': 'Hindi'
}

# Skin Disease Prediction Setup
class_label_mapping = {
    0: 'Actinic keratosis',
    1: 'Atopic Dermatitis',
    2: 'Benign keratosis',
    3: 'Dermatofibroma',
    4: 'Melanocytic nevus',
    5: 'Melanoma',
    6: 'Squamous cell carcinoma',
    7: 'Vascular lesion'
}

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model = models.vgg16(pretrained=True)
model.classifier = nn.Sequential(
    nn.Linear(model.classifier[0].in_features, 4096),
    nn.ReLU(),
    nn.Dropout(0.5),
    nn.Linear(4096, 4096),
    nn.ReLU(),
    nn.Dropout(0.5),
    nn.Linear(4096, len(class_label_mapping))
)
model.load_state_dict(torch.load('morning.pth', map_location=device))
model = model.to(device)
model.eval()

transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
])

def geocode_city(city_name):
    geolocator = Nominatim(user_agent="health_assistant")
    try:
        location = geolocator.geocode(city_name, exactly_one=True)
        return (location.latitude, location.longitude) if location else (None, None)
    except Exception as e:
        return None, None

@app.route('/geocode', methods=['GET'])
def geocode():
    city = request.args.get('city')
    if not city:
        return jsonify({'error': 'City name is required'}), 400
    lat, lon = geocode_city(city)
    if lat is None or lon is None:
        return jsonify({'error': 'Could not retrieve location'}), 404
    return jsonify({'latitude': lat, 'longitude': lon})

def get_hospitals(lat, lon):
    overpass_url = "https://overpass-api.de/api/interpreter"
    overpass_query = f"""
    [out:json];
    node["amenity"="hospital"](around:20000,{lat},{lon});
    out center;
    """
    try:
        response = requests.get(overpass_url, params={'data': overpass_query}, timeout=15)
        return response.json().get('elements', [])[:15] if response.status_code == 200 else []
    except Exception as e:
        print("Hospital fetch error:", e)
        return []

# Configure Google Gemini API
genai.configure(api_key=os.getenv("GOOGLE_GEMINI_API_KEY"))

def generate_analysis(context):
    try:
        model = genai.GenerativeModel("gemini-1.5-flash")
        response = model.generate_content(context)
        if response.text.strip():
            return response.text.strip()
        else:
            return "Analysis failed. Please consult a doctor."
    except Exception as e:
        print("Error generating analysis:", e)
        return "Analysis could not be completed."

def generate_question(context, language):
    model = genai.GenerativeModel("gemini-1.5-flash")
    lang_name = language_names.get(language, 'English')
    prompt_template = f"""You are a multilingual medical assistant helping users diagnose potential diseases based on their symptoms. Ask a follow-up question in {lang_name} based on:
    {{context}}
    Focus on aspects that help diagnose the condition. Focus on key factors like duration, severity, associated symptoms, and medical history. Ask only one question."""
    response = model.generate_content(prompt_template.format(context=context))
    return response.text.strip()

def generate_pdf_report(user_info, analysis_text, hospital_info=None, language='en'):
    pdf = FPDF()
    pdf.add_page()

    # Font fallbacks
    try:
        pdf.add_font('NotoSans', '', 'NotoSans-Regular.ttf', uni=True)
    except:
        pdf.add_font('Arial', '', 'arial.ttf', uni=True)

    pdf.set_font('Arial', '', 12)

    # Header
    pdf.cell(200, 10, txt=translations[language]['analysis_title'], ln=1, align='C')

    # Patient Information
    pdf.set_font("Arial", 'B', 12)
    pdf.cell(200, 10, txt=translations[language]['patient_info'], ln=1)
    pdf.set_font("Arial", '', 12)
    pdf.cell(200, 10, txt=f"{translations[language]['age']}: {user_info['age']}", ln=1)
    pdf.cell(200, 10, txt=f"{translations[language]['gender']}: {user_info['gender']}", ln=1)
    pdf.cell(200, 10, txt=f"{translations[language]['location']}: {user_info['location']}", ln=1)

    # Medical Analysis
    pdf.ln(10)
    pdf.set_font("Arial", 'B', 12)
    pdf.cell(200, 10, txt=translations[language]['medical_analysis'], ln=1)
    pdf.set_font("Arial", '', 12)
    pdf.multi_cell(0, 10, txt=analysis_text)

    # Hospitals
    if hospital_info and any(h.get('name') for h in hospital_info):
        pdf.add_page()
        pdf.set_font("Arial", 'B', 12)
        pdf.cell(200, 10, txt=translations[language]['hospitals'], ln=1)
        pdf.set_font("Arial", '', 12)
        for idx, hospital in enumerate(hospital_info[:5], 1):
            pdf.cell(200, 10, txt=f"{idx}. {hospital['name']}", ln=1)
            pdf.multi_cell(0, 10, txt=f"   {translations[language]['address']}: {hospital.get('address', 'N/A')}")

    return bytes(pdf.output(dest='S'))

@app.route('/')
def home():
    if 'logged_in' not in session:
        session['logged_in'] = False
    return render_template('home.html', translations=translations, session=session)

@app.route('/index')
def dashboard():
    if 'logged_in' not in session or not session['logged_in']:
        return redirect(url_for('login'))
    past_chats = list(chat_history_collection.find({"user": session['current_user']}))
    return render_template('index.html', translations=translations, session=session, past_chats=past_chats)

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        hashed_password = hashlib.sha256(password.encode()).hexdigest()
        user = users_collection.find_one({"username": username})
        if user and user['password'] == hashed_password:
            session['logged_in'] = True
            session['current_user'] = username
            session['selected_language'] = 'en'
            # Redirect to the dashboard page after login
            return redirect(url_for('dashboard'))
        else:
            return render_template('login.html', error="Invalid credentials")
    return render_template('login.html')

@app.route('/signup', methods=['GET', 'POST'])
def signup():
    if request.method == 'POST':
        new_username = request.form['new_username']
        new_password = request.form['new_password']
        age = int(request.form['age'])
        gender = request.form['gender']
        dob = datetime.strptime(request.form['dob'], '%Y-%m-%d').date()
        
        # Validate date of birth
        if dob > date.today():
            flash("Date of birth cannot be in the future", "error")
            return redirect(url_for('signup'))
        
        # Check if username already exists
        if users_collection.find_one({"username": new_username}):
            flash("Username already exists", "error")
            return redirect(url_for('signup'))
        
        # Hash the password
        hashed_pw = hashlib.sha256(new_password.encode()).hexdigest()
        
        # Prepare user data
        user_data = {
            'username': new_username,
            'password': hashed_pw,
            'age': age,
            'gender': gender,
            'dob': datetime.combine(dob, datetime.min.time())
        }
        
        # Insert user data into the database
        users_collection.insert_one(user_data)
        
        # Update session variables
        session['logged_in'] = True
        session['current_user'] = new_username
        session['selected_language'] = 'en'
        
        # Flash success message
        flash("Account created successfully! Please log in.", "success")
        
        # Redirect to the login page after successful signup
        return redirect(url_for('login'))
    
    # Render the signupppp.html template for GET requests
    return render_template('signup.html')

@app.route('/logout')
def logout():
    session.clear()
    return redirect(url_for('login'))

@app.route('/start_consultation', methods=['POST'])
def start_consultation():
    location = request.form['location']
    user_data = users_collection.find_one({"username": session['current_user']})
    if not user_data:
        return "User data not found", 400

    session['user_info'] = {
        'age': user_data['age'],
        'gender': user_data['gender'],
        'location': location
    }
    session['step'] = 'issue_type'
    session['responses'] = {'location': location}
    session['chat_history'] = []
    session['chat_history'].append({
        "role": "assistant",
        "content": translations[session.get('selected_language', 'en')]['whats_bothering']
    })
    session['followup_count'] = 0
    session['hospital_info'] = None
    return redirect(url_for('consultation'))

@app.route('/consultation', methods=['GET', 'POST'])
def consultation():
    if not session.get('logged_in'):
        return redirect(url_for('login'))

    # Initialize session variables if not already set
    if 'step' not in session:
        session['step'] = 'issue_type'
        session['responses'] = {}
        session['chat_history'] = []
        session['followup_count'] = 0
        session['hospital_info'] = None

    if request.method == 'POST':
        if session['step'] == 'issue_type':
            issue = request.form['issue']
            try:
                lang = detect(issue)
            except LangDetectException:
                lang = 'en'

            session['selected_language'] = lang if lang in ['ta', 'hi'] else 'en'
            keywords = skin_keywords.get(session['selected_language'], skin_keywords['en'])
            is_skin_issue = any(keyword.lower() in issue.lower() for keyword in keywords)

            if is_skin_issue:
                session['chat_history'].append({
                    "role": "assistant",
                    "content": translations[session['selected_language']]['upload_image']
                })
                session['step'] = 'skin_image'
            else:
                session['chat_history'].append({
                    "role": "assistant",
                    "content": translations[session['selected_language']]['general_response']
                })
                session['step'] = 'general_questions'

        elif session['step'] in ['skin_questions', 'general_questions']:
            answer = request.form['answer']
            session['responses'][f"q{session['followup_count']}"] = answer
            session['chat_history'].append({"role": "user", "content": answer})
            session['followup_count'] += 1

            if session['followup_count'] >= 5:
                session['step'] = 'analysis'
                print("Follow-up count:", session['followup_count'])
                print("Current Step:", session['step'])

            else:
                context = "\n".join([f"{msg['role']}: {msg['content']}" for msg in session['chat_history']])
                question = generate_question(context, session['selected_language'])
                session['chat_history'].append({"role": "assistant", "content": question})

        elif session['step'] == 'analysis':
            try:
                # Prepare context for analysis
                context = {
                    "responses": "\n".join([f"{k}: {v}" for k, v in session['responses'].items()]),
                    "prediction": session['responses'].get('skin_prediction', 'General Health Concern'),
                    "language": language_names[session['selected_language']]
}

                # Generate medical analysis
                analysis_prompt = f"""Analyze this health case in {context['language']}:
                {context['responses']}
                Provide:
                1. Likely diagnosis (consider {context['prediction']})
                2. Possible causes
                3. Treatment recommendations
                4. Prevention tips
                5. When to see doctor
                Use patient-friendly {context['language']} language."""
                analysis = generate_analysis(analysis_prompt)

                if not analysis.strip():
                    raise ValueError("Empty analysis generated")

                session['analysis_text'] = analysis
                session.modified = True  # Force session save

            except Exception as e:
                session['analysis_text'] = "Could not generate analysis. Please consult a medical professional."
                session.modified = True

            # Fetch nearby hospitals
            location = session['responses'].get('location')
            if location:
                lat, lon = geocode_city(location)
                if lat and lon:
                    hospitals = get_hospitals(lat, lon)
                    session['hospital_info'] = [
                        {
                            'name': h.get('tags', {}).get('name', 'Unknown Hospital'),
                            'address': ', '.join(filter(None, [
                                h.get('tags', {}).get('addr:street'),
                                h.get('tags', {}).get('addr:city') or location,
                                h.get('tags', {}).get('addr:postcode')
                            ])),
                            'lat': h.get('lat'),
                            'lon': h.get('lon')
                        }
                        for h in hospitals if h.get('lat') and h.get('lon')
                    ]
                else:
                    session['hospital_info'] = []

                session.modified = True  # Force session save

            session['step'] = 'complete'
            print("Session keys:", session.keys())
            print("Session step:", session.get('step'))
            print("Analysis Text:", session.get('analysis_text', 'Not set'))

    return render_template('consultation.html', translations=translations, session=session)

@app.route('/upload_skin_image', methods=['POST'])
def upload_skin_image():
    if 'file' not in request.files:
        return "No file uploaded", 400
    file = request.files['file']
    if file.filename == '':
        return "No selected file", 400
    image = Image.open(file).convert('RGB')
    with torch.no_grad():
        image_tensor = transform(image).unsqueeze(0).to(device)
        output = model(image_tensor)
        _, predicted = torch.max(output, 1)
        prediction = class_label_mapping[predicted.item()]
    session['responses']['skin_prediction'] = prediction
    session['chat_history'].append({
        "role": "assistant",
        "content": translations[session.get('selected_language', 'en')]['skin_response']
    })
    session['step'] = 'skin_questions'
    return redirect(url_for('consultation'))

@app.route('/generate_report')
def generate_report():
    if 'user_info' not in session:
        return "Error: User information is missing.", 400
    if 'analysis_text' not in session or not session['analysis_text'].strip():
        session['analysis_text'] = "No analysis available. Please consult a doctor."


    user_info = session['user_info']
    analysis_text = session['analysis_text']
    hospital_info = session.get('hospital_info', [])
    pdf_bytes = generate_pdf_report(user_info, analysis_text, hospital_info, session.get('selected_language', 'en'))
    return send_file(io.BytesIO(pdf_bytes), mimetype='application/pdf', as_attachment=True, download_name='medical_report.pdf')

@app.route('/map')
def show_map():
    hospital_info = session.get('hospital_info', [])
    if not hospital_info:
        return "No hospitals found", 400

    # Create a DataFrame for the map
    map_data = pd.DataFrame([
        {'name': h['name'], 'address': h['address'], 'lat': h['lat'], 'lon': h['lon']}
        for h in hospital_info
    ])

    # Render the map template
    return render_template('map.html', map_data=map_data.to_dict(orient='records'))

if __name__ == '__main__':
    app.run(debug=True)